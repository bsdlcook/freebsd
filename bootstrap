#!/usr/bin/env bash
# shellcheck disable=SC2015

# bootstrap --- Syne's FreeBSD setup.
# Copyright (C) 2019 syne

# Author: syne <syne@wired.sh>
# URL: https://gitlab.com/syne/freebsd/bootstrap
# Version:
SCRIPT_VERSION="2.26"

# Global variables.

# Script metadata:
SCRIPT_FILE=$(basename "${BASH_SOURCE[0]}")
SCRIPT_REPO="https://gitlab.com/syne/freebsd"
SCRIPT_BACKTITLE="FreeBSD bootstrap script : Version $SCRIPT_VERSION : $SCRIPT_REPO"

# Key files:
PACKAGE_FILE="./packages.full"
DATABASE_FILE="/var/db/pkg/repo-FreeBSD.sqlite"

# Dialog default size(s):
DIALOG_HEIGHT=10
DIALOG_WIDTH=50
DIALOG_OK=0
DIALOG_CANCEL=1
DIALOG_EXTRA=3

# Re-execute the script, allowing user to return back to the main dialog.
exec_script()
{
	exec "$0" ./"$SCRIPT_FILE"
}

# Dialog to display information about the script and repository.
about()
{
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "About" --msgbox "\n\nThis repository is my current FreeBSD setup as of June 2018 to present, which comes with my custom configuration files. By running this script it'll bootstrap my setup to your user of choice: required packages are installed, configuration files are copied, the suckless utils are compiled and any subsequent services are enabled. Before running this I assume you've met the prerequisites, taking the preliminary actions needed in order to complete the setup successfully. For further information checkout the README regarding the setup.\n\nhttps://gitlab.com/syne/freebsd" 23 $DIALOG_WIDTH 
	exec_script
}

# Preliminary checks before the installer is executed.
#
# This checks for the following:
#      * The user executing the script has the correct permissions set;
#      * The package 'doas' is installed, which is needed to escalate privileges.
#
# Granted these are met, the user can proceed with the installation.
preinstall_check()
{
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Preinstall check" --msgbox "\n\nTo begin lets check the current user permissions." $DIALOG_HEIGHT $DIALOG_WIDTH 
	
	[[ "$(id -u)" -eq 0 ]] && {
		dialog --backtitle "$SCRIPT_BACKTITLE" --title "Abort" \
			--no-label "Exit" --yes-label "Restart" --yesno \
			"\n\nPlease re-run this script as a non-privileged user." $DIALOG_HEIGHT $DIALOG_WIDTH
		[[ $? -eq $DIALOG_CANCEL ]] && exit || exec_script
	}

	[[ -z "$(pkg info -x security/doas 2>/dev/null | head -n1)" ]] && {
		dialog --backtitle "$SCRIPT_BACKTITLE" --title "Abort" \
			--no-label "Exit" --yes-label "Restart" --yesno \
			"\n\nPlease install doas by typing: 'pkg install security/doas' with a privileged user; after add your user account with the command: echo 'permit nopass your_user as root' | tee -s /usr/local/etc/doas.conf - then re-run the script." 0 $DIALOG_WIDTH 
		[[ $? -eq $DIALOG_CANCEL ]] && exit || exec_script
	}

	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Preinstall check" --msgbox "\n\nPreinstall user check passed without any errors." $DIALOG_HEIGHT $DIALOG_WIDTH
}

# Function to determine and install package given from the first paramater.
has_package()
{
	[[ -z "$(pkg info -x "$1" 2>/dev/null | head -n1)" ]] && doas pkg install -y "$1" &>/dev/null
}

# Firstly, assuming that everything has executed correctly, the function will read the file 'packages.full' from the
# current directory. 'packages.full' contains a list of packages to be installed, alongside a value to
# determine if the package is enabled by default (mainly for a few extra packages such as VirtualBox and
# the NVIDIA GPU display drivers).
#
# Secondly, the package file is parsed into an array with it's 'on'/'off' value with the while loop. The user
# is prompted with a checklist of packages to be installed, and if none are selected shown an error. The process
# of fetching the package begins via 'pkg': a visable progress-bar is displayed to indicate the amount of packages
# left to download.
#
# Lastly, once everything has been installed we move onto the next step - bootstrapping the files.  
package_install()
{
	[[ ! -f $PACKAGE_FILE ]] && {
		dialog --backtitle "$SCRIPT_BACKTITLE" --title "Abort" \
			--no-label "Exit" --yes-label "Restart" --yesno \
			"\n\nPackage file '$PACKAGE_FILE' not found in directory. Please ensure the integrity of the files are not missing or corrupted." 10 50
		[[ $? -eq $DIALOG_CANCEL ]] && exit || exec_script
	}

	[[ ! -f $DATABASE_FILE ]] && {
		dialog --backtitle "$SCRIPT_BACKTITLE" --title "Package metadata" --msgbox "\n\nBefore we begin the package repository will be updated." 10 50
		doas pkg update -f 2>/dev/null
	}

	local __COUNT=0
	local __PACKAGES=()
	local __SELECTED
	while read -r PACKAGE OPT; do
		((++__COUNT))
		__PACKAGES+=("$PACKAGE" "$(pkg rquery -i "%c" "$PACKAGE")" "$OPT")
	done < "$PACKAGE_FILE"
	__SELECTED=$(dialog --backtitle "$SCRIPT_BACKTITLE" --title "Select packages" --cancel-label "Back" --checklist "" 0 0 "$__COUNT" "${__PACKAGES[@]}" --stdout)			
	[[ $? -eq $DIALOG_CANCEL ]] && exec_script
	
	mapfile -t __UPDATED_PACKAGES < <(printf "%s" "$__SELECTED" | tr " " "\n")
	[[ -z "${__UPDATED_PACKAGES[*]}" ]] && {
		dialog --backtitle "$SCRIPT_BACKTITLE" --title "Abort" \
			--no-label "Exit" --yes-label "Restart" --yesno \
			"\n\nNo packages have been selected for installation." $DIALOG_HEIGHT $DIALOG_WIDTH
		[[ $? -eq $DIALOG_CANCEL ]] && exit || exec_script
	}

	local __COUNTER=0
	local __PACKAGE_COUNT="${#__UPDATED_PACKAGES[@]}"
	dialog --title "Fetching supplied packages" --backtitle "$SCRIPT_BACKTITLE" --gauge "" 10 55 < <(
		for PACKAGE in ${__UPDATED_PACKAGES[*]}; do
			STATUS=$((100*(++__COUNTER)/__PACKAGE_COUNT))
		cat <<EOF
XXX
$STATUS

Downloading package $PACKAGE ($__COUNTER/$__PACKAGE_COUNT)

Please wait...
XXX
EOF
			has_package "$PACKAGE"
		done
	)
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Packages installed" --msgbox "\n\nAll $__PACKAGE_COUNT corresponding packages have been installed successfully." $DIALOG_HEIGHT $DIALOG_WIDTH 
}

# Bootstraps into the users home directory that contains all the necessary configuration files. As with the package installer dialog,
# each file that's copied is shown on the screen with a neat little progress-bar.
bootstrap_files()
{
	local __COUNTER=0
	local __FILE_COUNT
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Bootstrapping" --gauge "" 10 55 < <(
		mapfile -t __FILES < <(find {.config,.scripts,.suckless,.xinitrc,.tmux.conf} -type f 2>/dev/null)
		
		__FILE_COUNT="${#__FILES[@]}"
		for FILE in ${__FILES[*]}; do
			STATUS=$((100*(++__COUNTER)/__FILE_COUNT))
			cat <<EOF
XXX
$STATUS

Copying file $FILE ($__COUNTER/$__FILE_COUNT)

Please wait...
XXX
EOF
			echo "$FILE" | cpio -p -d "/usr/home/$USER" &>/dev/null
		done
	)
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Bootstrap complete" --msgbox "\n\nConfiguration files have been copied to your home directory." $DIALOG_HEIGHT $DIALOG_WIDTH
}

# Compile the plethora of suckless utils and install them. 
compile_utils()
{
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Suckless utilities" --msgbox "\n\nThe suckless utils will now be compiled and installed on your system." 10 50
	doas make CC="ccache cc" install clean -C "$HOME/.suckless/dwm"
	doas make CC="ccache cc" install clean -C "$HOME/.suckless/st"
	doas make CC="ccache cc" install clean -C "$HOME/.suckless/dmenu"
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Suckless utilities" --msgbox "\n\nCompilation complete." 10 50
}

# Prompt the user if they're running within VirtualBox, if so, enable the needed services at startup.
virtualbox_enable()
{
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "VirtualBox" --yesno "\n\nAre you running this machine in VirtualBox?" $DIALOG_HEIGHT $DIALOG_WIDTH
	[[ $? -eq $DIALOG_OK ]] && {
		doas sysrc vboxguest_enable="YES" >/dev/null
		doas sysrc vboxservice_enable="YES" >/dev/null
	}
}

# Prompt the user if they're using a NVIDIA GPU and enable the corresponding services needed. This will also install the 'nvidia-xconfig' package
# that'll generate the correct Xorg configuration file.
nvidia_enable()
{
	dialog --backtitle "$SCRIPT_BACKTITLE" --title "NVIDIA Drivers" --yesno "\n\nAre you using an NVIDIA GPU?" $DIALOG_HEIGHT $DIALOG_WIDTH
	[[ $? -eq $DIALOG_OK ]] && {
	        echo "linux_load=\"YES\"" | doas tee -a /boot/loader.conf >/dev/null
	        echo "nvidia-modeset_load=\"YES\"" | doas tee -a /boot/loader.conf >/dev/null
		has_package x11/nvidia-xconfig
		doas nvidia-xconfig
	}
}

# Prompt the user everything has completed with success, optionally being able to reboot the system (recommended) or exit the script.
finish()
{
		dialog --backtitle "$SCRIPT_BACKTITLE" --title "Installation finished" \
			--no-label "Exit" --yes-label "Reboot" --yesno \
			"\n\nBootstrap completed. Please reboot your system to finalize the changes." $DIALOG_HEIGHT $DIALOG_WIDTH
		[[ $? -eq $DIALOG_OK ]] && doas reboot || exit	
}

# Main function that prompts the user with three options:
# 1: Install;
# 2: About;
# 3: Exit.
#
# Depending on what option is selected, the appropriate function will be ran.
main()
{
	local MENU_INSTALL=$DIALOG_OK
	local MENU_EXIT=$DIALOG_CANCEL
	local MENU_ABOUT=$DIALOG_EXTRA

	dialog --backtitle "$SCRIPT_BACKTITLE" --title "Welcome" --extra-button --extra-label "About" --ok-label "Install" --cancel-label "Exit" --yesno "\n\nWelcome to syne's FreeBSD bootstrap script v$SCRIPT_VERSION! To begin the setup please select the install option." $DIALOG_HEIGHT $DIALOG_WIDTH 

	case $? in
		$MENU_INSTALL)
			# Check user permissions.
			preinstall_check
			
			# Install selected packages.
			package_install
			
			# Set the default user-shell to fish.
			doas chsh -s "$(command -v fish)" "$USER"	
			
			# Generate machine-id and enable dbus startup services.
			dbus-uuidgen | doas tee /etc/machine-id >/dev/null 
			doas sysrc dbus_enable="YES" >/dev/null
			doas sysrc hald_enable="YES" >/dev/null
		
			# Load the Linux module needed to install the NVIDIA driver.
			kldload linux.ko

			# Bootstrap files to user directory.
			bootstrap_files

			# Symlink scripts to /usr/local/bin (needed for dwm keybinds).
			doas ln -s "$HOME/.scripts/"{open-stream,screenshot} /usr/local/bin 2>/dev/null

			# Compile Suckless utilities.
			compile_utils

			# Check if running in VirtualBox.
			virtualbox_enable
			
			# Check if running NVIDIA GPU.
			nvidia_enable

			# Finalize changes (requires hard-reboot).
			finish
			;;
		$MENU_EXIT)
		        # Exit the script and do nothing.
		        exit 0 
			;;
		$MENU_ABOUT)
			# Display the about dialog.
			about
			;;
	esac
}

# Begin the fun.
main "$@"
